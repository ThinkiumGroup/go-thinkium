// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.1.0
// - protoc             v3.19.1
// source: server.proto

package rpcserver

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// NodeClient is the client API for Node service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeClient interface {
	Ping(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*RpcResponse, error)
	GetAccount(ctx context.Context, in *RpcAddress, opts ...grpc.CallOption) (*RpcResponse, error)
	GetTransactionByHash(ctx context.Context, in *RpcTXHash, opts ...grpc.CallOption) (*RpcResponse, error)
	GetTransactions(ctx context.Context, in *RpcTxList, opts ...grpc.CallOption) (*RpcResponse, error)
	SendTx(ctx context.Context, in *RpcTx, opts ...grpc.CallOption) (*RpcResponse, error)
	GetStats(ctx context.Context, in *RpcStatsReq, opts ...grpc.CallOption) (*RpcResponse, error)
	GetBlockHeader(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcResponse, error)
	GetBlock(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcRespondStream, error)
	GetBlockHeaders(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcResponse, error)
	GetBlockTxs(ctx context.Context, in *RpcBlockTxsReq, opts ...grpc.CallOption) (*RpcResponse, error)
	CallTransaction(ctx context.Context, in *RpcTx, opts ...grpc.CallOption) (*RpcResponse, error)
	GetChainInfo(ctx context.Context, in *RpcChainInfoReq, opts ...grpc.CallOption) (*RpcResponse, error)
	GetCommittee(ctx context.Context, in *RpcChainEpoch, opts ...grpc.CallOption) (*RpcResponse, error)
	MakeVccProof(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error)
	MakeCCCExistenceProof(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error)
	GetCCCRelativeTx(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error)
	GetAccountWithChainHeight(ctx context.Context, in *RpcAddress, opts ...grpc.CallOption) (*RpcResponse, error)
	GetRRProofs(ctx context.Context, in *RpcRRProofReq, opts ...grpc.CallOption) (*RpcResponse, error)
	GetRRCurrent(ctx context.Context, in *RpcChainRequest, opts ...grpc.CallOption) (*RpcResponse, error)
	SendBlock(ctx context.Context, in *RpcMsgReq, opts ...grpc.CallOption) (*RpcResponse, error)
	TryCrypto(ctx context.Context, in *RpcMsgReq, opts ...grpc.CallOption) (*RpcResponse, error)
}

type nodeClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeClient(cc grpc.ClientConnInterface) NodeClient {
	return &nodeClient{cc}
}

func (c *nodeClient) Ping(ctx context.Context, in *RpcRequest, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetAccount(ctx context.Context, in *RpcAddress, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetAccount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetTransactionByHash(ctx context.Context, in *RpcTXHash, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetTransactions(ctx context.Context, in *RpcTxList, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetTransactions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SendTx(ctx context.Context, in *RpcTx, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/SendTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetStats(ctx context.Context, in *RpcStatsReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetBlockHeader(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetBlockHeader", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetBlock(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcRespondStream, error) {
	out := new(RpcRespondStream)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetBlockHeaders(ctx context.Context, in *RpcBlockHeight, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetBlockHeaders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetBlockTxs(ctx context.Context, in *RpcBlockTxsReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetBlockTxs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) CallTransaction(ctx context.Context, in *RpcTx, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/CallTransaction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetChainInfo(ctx context.Context, in *RpcChainInfoReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetChainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetCommittee(ctx context.Context, in *RpcChainEpoch, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetCommittee", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) MakeVccProof(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/MakeVccProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) MakeCCCExistenceProof(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/MakeCCCExistenceProof", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetCCCRelativeTx(ctx context.Context, in *RpcCashCheck, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetCCCRelativeTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetAccountWithChainHeight(ctx context.Context, in *RpcAddress, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetAccountWithChainHeight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetRRProofs(ctx context.Context, in *RpcRRProofReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetRRProofs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) GetRRCurrent(ctx context.Context, in *RpcChainRequest, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/GetRRCurrent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) SendBlock(ctx context.Context, in *RpcMsgReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/SendBlock", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeClient) TryCrypto(ctx context.Context, in *RpcMsgReq, opts ...grpc.CallOption) (*RpcResponse, error) {
	out := new(RpcResponse)
	err := c.cc.Invoke(ctx, "/rpcserver.node/TryCrypto", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeServer is the server API for Node service.
// All implementations must embed UnimplementedNodeServer
// for forward compatibility
type NodeServer interface {
	Ping(context.Context, *RpcRequest) (*RpcResponse, error)
	GetAccount(context.Context, *RpcAddress) (*RpcResponse, error)
	GetTransactionByHash(context.Context, *RpcTXHash) (*RpcResponse, error)
	GetTransactions(context.Context, *RpcTxList) (*RpcResponse, error)
	SendTx(context.Context, *RpcTx) (*RpcResponse, error)
	GetStats(context.Context, *RpcStatsReq) (*RpcResponse, error)
	GetBlockHeader(context.Context, *RpcBlockHeight) (*RpcResponse, error)
	GetBlock(context.Context, *RpcBlockHeight) (*RpcRespondStream, error)
	GetBlockHeaders(context.Context, *RpcBlockHeight) (*RpcResponse, error)
	GetBlockTxs(context.Context, *RpcBlockTxsReq) (*RpcResponse, error)
	CallTransaction(context.Context, *RpcTx) (*RpcResponse, error)
	GetChainInfo(context.Context, *RpcChainInfoReq) (*RpcResponse, error)
	GetCommittee(context.Context, *RpcChainEpoch) (*RpcResponse, error)
	MakeVccProof(context.Context, *RpcCashCheck) (*RpcResponse, error)
	MakeCCCExistenceProof(context.Context, *RpcCashCheck) (*RpcResponse, error)
	GetCCCRelativeTx(context.Context, *RpcCashCheck) (*RpcResponse, error)
	GetAccountWithChainHeight(context.Context, *RpcAddress) (*RpcResponse, error)
	GetRRProofs(context.Context, *RpcRRProofReq) (*RpcResponse, error)
	GetRRCurrent(context.Context, *RpcChainRequest) (*RpcResponse, error)
	SendBlock(context.Context, *RpcMsgReq) (*RpcResponse, error)
	TryCrypto(context.Context, *RpcMsgReq) (*RpcResponse, error)
	mustEmbedUnimplementedNodeServer()
}

// UnimplementedNodeServer must be embedded to have forward compatible implementations.
type UnimplementedNodeServer struct {
}

func (UnimplementedNodeServer) Ping(context.Context, *RpcRequest) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedNodeServer) GetAccount(context.Context, *RpcAddress) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccount not implemented")
}
func (UnimplementedNodeServer) GetTransactionByHash(context.Context, *RpcTXHash) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactionByHash not implemented")
}
func (UnimplementedNodeServer) GetTransactions(context.Context, *RpcTxList) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTransactions not implemented")
}
func (UnimplementedNodeServer) SendTx(context.Context, *RpcTx) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTx not implemented")
}
func (UnimplementedNodeServer) GetStats(context.Context, *RpcStatsReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStats not implemented")
}
func (UnimplementedNodeServer) GetBlockHeader(context.Context, *RpcBlockHeight) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeader not implemented")
}
func (UnimplementedNodeServer) GetBlock(context.Context, *RpcBlockHeight) (*RpcRespondStream, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlock not implemented")
}
func (UnimplementedNodeServer) GetBlockHeaders(context.Context, *RpcBlockHeight) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockHeaders not implemented")
}
func (UnimplementedNodeServer) GetBlockTxs(context.Context, *RpcBlockTxsReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockTxs not implemented")
}
func (UnimplementedNodeServer) CallTransaction(context.Context, *RpcTx) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTransaction not implemented")
}
func (UnimplementedNodeServer) GetChainInfo(context.Context, *RpcChainInfoReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChainInfo not implemented")
}
func (UnimplementedNodeServer) GetCommittee(context.Context, *RpcChainEpoch) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCommittee not implemented")
}
func (UnimplementedNodeServer) MakeVccProof(context.Context, *RpcCashCheck) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeVccProof not implemented")
}
func (UnimplementedNodeServer) MakeCCCExistenceProof(context.Context, *RpcCashCheck) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeCCCExistenceProof not implemented")
}
func (UnimplementedNodeServer) GetCCCRelativeTx(context.Context, *RpcCashCheck) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCCCRelativeTx not implemented")
}
func (UnimplementedNodeServer) GetAccountWithChainHeight(context.Context, *RpcAddress) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAccountWithChainHeight not implemented")
}
func (UnimplementedNodeServer) GetRRProofs(context.Context, *RpcRRProofReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRRProofs not implemented")
}
func (UnimplementedNodeServer) GetRRCurrent(context.Context, *RpcChainRequest) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRRCurrent not implemented")
}
func (UnimplementedNodeServer) SendBlock(context.Context, *RpcMsgReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendBlock not implemented")
}
func (UnimplementedNodeServer) TryCrypto(context.Context, *RpcMsgReq) (*RpcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryCrypto not implemented")
}
func (UnimplementedNodeServer) mustEmbedUnimplementedNodeServer() {}

// UnsafeNodeServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeServer will
// result in compilation errors.
type UnsafeNodeServer interface {
	mustEmbedUnimplementedNodeServer()
}

func RegisterNodeServer(s grpc.ServiceRegistrar, srv NodeServer) {
	s.RegisterService(&Node_ServiceDesc, srv)
}

func _Node_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).Ping(ctx, req.(*RpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetAccount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetAccount(ctx, req.(*RpcAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcTXHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetTransactionByHash(ctx, req.(*RpcTXHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcTxList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetTransactions(ctx, req.(*RpcTxList))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SendTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/SendTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendTx(ctx, req.(*RpcTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcStatsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetStats(ctx, req.(*RpcStatsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetBlockHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcBlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetBlockHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetBlockHeader",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetBlockHeader(ctx, req.(*RpcBlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcBlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetBlock(ctx, req.(*RpcBlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetBlockHeaders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcBlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetBlockHeaders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetBlockHeaders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetBlockHeaders(ctx, req.(*RpcBlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetBlockTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcBlockTxsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetBlockTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetBlockTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetBlockTxs(ctx, req.(*RpcBlockTxsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_CallTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).CallTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/CallTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).CallTransaction(ctx, req.(*RpcTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetChainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcChainInfoReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetChainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetChainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetChainInfo(ctx, req.(*RpcChainInfoReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetCommittee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcChainEpoch)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetCommittee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetCommittee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetCommittee(ctx, req.(*RpcChainEpoch))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_MakeVccProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcCashCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).MakeVccProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/MakeVccProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).MakeVccProof(ctx, req.(*RpcCashCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_MakeCCCExistenceProof_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcCashCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).MakeCCCExistenceProof(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/MakeCCCExistenceProof",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).MakeCCCExistenceProof(ctx, req.(*RpcCashCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetCCCRelativeTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcCashCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetCCCRelativeTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetCCCRelativeTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetCCCRelativeTx(ctx, req.(*RpcCashCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetAccountWithChainHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetAccountWithChainHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetAccountWithChainHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetAccountWithChainHeight(ctx, req.(*RpcAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetRRProofs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcRRProofReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRRProofs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetRRProofs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRRProofs(ctx, req.(*RpcRRProofReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_GetRRCurrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcChainRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).GetRRCurrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/GetRRCurrent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).GetRRCurrent(ctx, req.(*RpcChainRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_SendBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).SendBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/SendBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).SendBlock(ctx, req.(*RpcMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Node_TryCrypto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RpcMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeServer).TryCrypto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpcserver.node/TryCrypto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeServer).TryCrypto(ctx, req.(*RpcMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Node_ServiceDesc is the grpc.ServiceDesc for Node service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Node_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpcserver.node",
	HandlerType: (*NodeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Node_Ping_Handler,
		},
		{
			MethodName: "GetAccount",
			Handler:    _Node_GetAccount_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _Node_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetTransactions",
			Handler:    _Node_GetTransactions_Handler,
		},
		{
			MethodName: "SendTx",
			Handler:    _Node_SendTx_Handler,
		},
		{
			MethodName: "GetStats",
			Handler:    _Node_GetStats_Handler,
		},
		{
			MethodName: "GetBlockHeader",
			Handler:    _Node_GetBlockHeader_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _Node_GetBlock_Handler,
		},
		{
			MethodName: "GetBlockHeaders",
			Handler:    _Node_GetBlockHeaders_Handler,
		},
		{
			MethodName: "GetBlockTxs",
			Handler:    _Node_GetBlockTxs_Handler,
		},
		{
			MethodName: "CallTransaction",
			Handler:    _Node_CallTransaction_Handler,
		},
		{
			MethodName: "GetChainInfo",
			Handler:    _Node_GetChainInfo_Handler,
		},
		{
			MethodName: "GetCommittee",
			Handler:    _Node_GetCommittee_Handler,
		},
		{
			MethodName: "MakeVccProof",
			Handler:    _Node_MakeVccProof_Handler,
		},
		{
			MethodName: "MakeCCCExistenceProof",
			Handler:    _Node_MakeCCCExistenceProof_Handler,
		},
		{
			MethodName: "GetCCCRelativeTx",
			Handler:    _Node_GetCCCRelativeTx_Handler,
		},
		{
			MethodName: "GetAccountWithChainHeight",
			Handler:    _Node_GetAccountWithChainHeight_Handler,
		},
		{
			MethodName: "GetRRProofs",
			Handler:    _Node_GetRRProofs_Handler,
		},
		{
			MethodName: "GetRRCurrent",
			Handler:    _Node_GetRRCurrent_Handler,
		},
		{
			MethodName: "SendBlock",
			Handler:    _Node_SendBlock_Handler,
		},
		{
			MethodName: "TryCrypto",
			Handler:    _Node_TryCrypto_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "server.proto",
}
